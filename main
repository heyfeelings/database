--Local whitlist
-- security dont change anything 
local http = require "gamesense/http" or error("Sub to https://gamesense.pub/forums/viewtopic.php?id=19253 on the lua workshop.")

local lp = entity.get_local_player

local function include(table, key)
    for i=1, #table do
        if table[i] == key then
            return true, i
        end
    end
    return false, nil
end

local function split(text, sep)
    local sep, fields = sep or ":", {}
    local pattern = string.format("([^%s]+)", sep)
    text:gsub(pattern, function(c)
        fields[#fields + 1] = c
    end)
    return fields
end

local function remove_spacing(text)
    return text:match("^%s*(.-)%s*$")
end

local web_data = "unknown"

local function get_web_data()
    http.get("https://pastebin.com/raw/nkpWzNSS", function(success, response)
        if success then
            web_data = response.body
            return
        else
            http.get("https://matrixllc.000webhostapp.com/", function(s, r)
                if s then
                    web_data = r.body
                    return
                else
                    client.color_log(255, 200, 0, "[Error] 0x01")
                end
            end)
        end
    end)
end

get_web_data()

local verified_user = false
local attempts = 1

local function check()
    local system_info = database.read("relax_hwid")

    if returned_data ~= "unknown" then
        local users = {
            name = {},
            hwid = {},
        }

        --Split strings into a table
        local strings = split(web_data, ",")

        print(strings)

        --Collect data, should work fine /shrug
        for i=1, #strings do
            local string = strings[i]
            if i % 2 == 1 then
                table.insert(users.name, remove_spacing(string))
            elseif i % 2 == 0 then
                table.insert(users.hwid, remove_spacing(string))
            end
        end

        local common_hwid, pos_in_table = include(users.hwid, system_info)

        if common_hwid == false then
            if attempts == 3 then
                client.color_log(255, 0, 0, "[Error] Out of login attempts, closing game.")
                client.delay_call(2, function()
                    print("exec.quit")
                end)
            else
                client.color_log(255, 200, 0, string.format("[Error] Invalid login, %d %s remaining.", 3 - attempts, (3 - attempts) > 1 and "attempts" or "attempt"))
            end
            attempts = attempts + 1
        else
            client.color_log(125, 255, 50, string.format("[Success] Logged in, welcome back %s.", users.name[pos_in_table]))
            verified_user = true
        end
    else
        client.color_log(255, 200, 0, "[relax] Bad web request, retrying...")
        --Update
        get_web_data()
        --Retry
        client.delay_call(2, check)
    end
end

local hide = ui.new_button("AA", "Anti-Aimbot Angles", "relax | Login", check)

--Nigga hash 
local cfg_caching = false
local floor,modf = math.floor,math.modf
local char,format,rep = string.char,string.format,string.rep
local function bytes_to_w32 (a,b,c,d) return a*0x1000000+b*0x10000+c*0x100+d end

local function w32_to_bytes (i)
   return floor(i/0x1000000)%0x100,floor(i/0x10000)%0x100,floor(i/0x100)%0x100,i%0x100
end

local function w32_rot (bits,a)
   local b2 = 2^(32-bits)
   local a,b = modf(a/b2)
   return a+b*b2*(2^(bits))
end

local function cache2arg (fn)
   if not cfg_caching then return fn end
   local lut = {}
   for i=0,0xffff do
      local a,b = floor(i/0x100),i%0x100
      lut[i] = fn(a,b)
   end
   return function (a,b)
      return lut[a*0x100+b]
   end
end

local function byte_to_bits (b)
   local b = function (n)
      local b = floor(b/n)
      return b%2==1
   end
   return b(1),b(2),b(4),b(8),b(16),b(32),b(64),b(128)
end

local function bits_to_byte (a,b,c,d,e,f,g,h)
   local function n(b,x) return b and x or 0 end
   return n(a,1)+n(b,2)+n(c,4)+n(d,8)+n(e,16)+n(f,32)+n(g,64)+n(h,128)
end

local function bits_to_string (a,b,c,d,e,f,g,h)
   local function x(b) return b and "1" or "0" end
   return ("%s%s%s%s %s%s%s%s"):format(x(a),x(b),x(c),x(d),x(e),x(f),x(g),x(h))
end

local function byte_to_bit_string (b)
   return bits_to_string(byte_to_bits(b))
end

local function w32_to_bit_string(a)
   if type(a) == "string" then return a end
   local aa,ab,ac,ad = w32_to_bytes(a)
   local s = byte_to_bit_string
   return ("%s %s %s %s"):format(s(aa):reverse(),s(ab):reverse(),s(ac):reverse(),s(ad):reverse()):reverse()
end

local band = cache2arg (function(a,b)
    local A,B,C,D,E,F,G,H = byte_to_bits(b)
    local a,b,c,d,e,f,g,h = byte_to_bits(a)
    return bits_to_byte(
        A and a, B and b, C and c, D and d,
        E and e, F and f, G and g, H and h)
end)

local bor = cache2arg(function(a,b)
    local A,B,C,D,E,F,G,H = byte_to_bits(b)
    local a,b,c,d,e,f,g,h = byte_to_bits(a)
    return bits_to_byte(
        A or a, B or b, C or c, D or d,
        E or e, F or f, G or g, H or h)
end)
local bxor = cache2arg(function(a,b)
    local A,B,C,D,E,F,G,H = byte_to_bits(b)
    local a,b,c,d,e,f,g,h = byte_to_bits(a)
    return bits_to_byte(
        A ~= a, B ~= b, C ~= c, D ~= d,
        E ~= e, F ~= f, G ~= g, H ~= h)
end)

local function bnot (x)
   return 255-(x % 256)
end

local function w32_comb(fn)
   return function (a,b)
      local aa,ab,ac,ad = w32_to_bytes(a)
      local ba,bb,bc,bd = w32_to_bytes(b)
      return bytes_to_w32(fn(aa,ba),fn(ab,bb),fn(ac,bc),fn(ad,bd))
   end
end

local w32_and = w32_comb(band)
local w32_xor = w32_comb(bxor)
local w32_or = w32_comb(bor)

local function w32_xor_n (a,...)
   local aa,ab,ac,ad = w32_to_bytes(a)
   for i=1,select('#',...) do
      local ba,bb,bc,bd = w32_to_bytes(select(i,...))
      aa,ab,ac,ad = bxor(aa,ba),bxor(ab,bb),bxor(ac,bc),bxor(ad,bd)
   end
   return bytes_to_w32(aa,ab,ac,ad)
end

local function w32_or3 (a,b,c)
   local aa,ab,ac,ad = w32_to_bytes(a)
   local ba,bb,bc,bd = w32_to_bytes(b)
   local ca,cb,cc,cd = w32_to_bytes(c)
   return bytes_to_w32(
      bor(aa,bor(ba,ca)), bor(ab,bor(bb,cb)), bor(ac,bor(bc,cc)), bor(ad,bor(bd,cd))
   )
end

local function w32_not (a)
   return 4294967295-(a % 4294967296)
end
 
local function w32_add (a,b) return (a+b) % 4294967296 end
 
local function w32_add_n (a,...)
   for i=1,select('#',...) do
      a = (a+select(i,...)) % 4294967296
   end
   return a
end
local function w32_to_hexstring (w) return format("%08x",w) end
 
local function to_hex(msg)
   local H0,H1,H2,H3,H4 = 0x67452301,0xEFCDAB89,0x98BADCFE,0x10325476,0xC3D2E1F0
   local msg_len_in_bits = #msg * 8
   
   local first_append = char(0x80)
   
   local non_zero_message_bytes = #msg +1 +8
   local current_mod = non_zero_message_bytes % 64
   local second_append = current_mod>0 and rep(char(0), 64 - current_mod) or ""
   
   local B1, R1 = modf(msg_len_in_bits / 0x01000000)
   local B2, R2 = modf( 0x01000000 * R1 / 0x00010000)
   local B3, R3 = modf( 0x00010000 * R2 / 0x00000100)
   local B4 = 0x00000100 * R3
   
   local L64 = char( 0) .. char( 0) .. char( 0) .. char( 0)
   .. char(B1) .. char(B2) .. char(B3) .. char(B4)
   
   msg = msg .. first_append .. second_append .. L64
   
   assert(#msg % 64 == 0)
   
   local chunks = #msg / 64
   
   local W = { }
   local start, A, B, C, D, E, f, K, TEMP
   local chunk = 0
   
   while chunk < chunks do

      start,chunk = chunk * 64 + 1,chunk + 1
      
      for t = 0, 15 do
         W[t] = bytes_to_w32(msg:byte(start, start + 3))
         start = start + 4
      end
      

      for t = 16, 79 do
         W[t] = w32_rot(1, w32_xor_n(W[t-3], W[t-8], W[t-14], W[t-16]))
      end
      
      A,B,C,D,E = H0,H1,H2,H3,H4
      
      for t = 0, 79 do
         if t <= 19 then
           
            f = w32_or(w32_and(B, C), w32_and(w32_not(B), D))
            K = 0x5A827999
         elseif t <= 39 then
          
            f = w32_xor_n(B, C, D)
            K = 0x6ED9EBA1
         elseif t <= 59 then
          
            f = w32_or3(w32_and(B, C), w32_and(B, D), w32_and(C, D))
            K = 0x8F1BBCDC
         else
     
            f = w32_xor_n(B, C, D)
            K = 0xCA62C1D6
         end
         
        
         A,B,C,D,E = w32_add_n(w32_rot(5, A), f, E, W[t], K),
         A, w32_rot(30, B), C, D
      end
      
      H0,H1,H2,H3,H4 = w32_add(H0, A),w32_add(H1, B),w32_add(H2, C),w32_add(H3, D),w32_add(H4, E)
   end
   local f = w32_to_hexstring
   return f(H0) .. f(H1) .. f(H2) .. f(H3) .. f(H4)
end

--HWID SHIT
local ffi = require("ffi")

ffi.cdef[[
	typedef int(__cdecl* cpuInfoFN)();
	typedef long long          int64_t;
	typedef unsigned char      uint8_t;
	typedef wchar_t WCHAR;

	typedef struct CPUInformation
	{
		int	 m_Size;		// Size of this structure, for forward compatability.

		uint8_t m_nLogicalProcessors;		// Number op logical processors.
		uint8_t m_nPhysicalProcessors;	// Number of physical processors

		bool m_bRDTSC : 1,	// Is RDTSC supported?
			m_bCMOV  : 1,  // Is CMOV supported?
			m_bFCMOV : 1,  // Is FCMOV supported?
			m_bSSE	  : 1,	// Is SSE supported?
			m_bSSE2  : 1,	// Is SSE2 Supported?
			m_b3DNow : 1,	// Is 3DNow! Supported?
			m_bMMX   : 1,	// Is MMX supported?
			m_bHT	  : 1;	// Is HyperThreading supported?


		bool m_bSSE3 : 1,
			m_bSSSE3 : 1,
			m_bSSE4a : 1,
			m_bSSE41 : 1,
			m_bSSE42 : 1,
			m_bAVX   : 1;  // Is AVX supported?

		int64_t m_Speed;						// In cycles per second.

		WCHAR* m_szProcessorID;				// Processor vendor Identification.
		WCHAR* m_szProcessorBrand;			// Processor brand string, if available

		uint32_t m_nModel;
		uint32_t m_nFeatures[ 3 ];
		uint32_t m_nL1CacheSizeKb;
		uint32_t m_nL1CacheDesc;
		uint32_t m_nL2CacheSizeKb;
		uint32_t m_nL2CacheDesc;
		uint32_t m_nL3CacheSizeKb;
		uint32_t m_nL3CacheDesc;
	};

	typedef struct MaterialAdapterInfo_t
	{
		char m_pDriverName[512];
		unsigned int m_VendorID;
		unsigned int m_DeviceID;
		unsigned int m_SubSysID;
		unsigned int m_relax;
		int m_nDXSupportLevel;			// This is the *preferred* dx support level
		int m_nMinDXSupportLevel;
		int m_nMaxDXSupportLevel;
		unsigned int m_nDriverVersionHigh;
		unsigned int m_nDriverVersionLow;
	};

	typedef int(__thiscall* get_current_adapter_fn)(void*);
	typedef void(__thiscall* get_adapter_info_fn)(void*, int adapter, struct MaterialAdapterInfo_t& info);
]]

-- cpu things
local info_raw_sig = client.find_signature("engine.dll", "\xE8\xCC\xCC\xCC\xCC\x8B\x45\xFC\x83\xC6\x58") or error("[Error] 0x01")
local info_raw_offset = ffi.cast("char*", info_raw_sig) + 92
local info_raw_final = ffi.cast("void*", info_raw_offset)
local cpu_info_func = ffi.cast("cpuInfoFN", info_raw_final) or error("[Error] 0x02")
local cpu_info_raw = cpu_info_func()
local cpu_info = ffi.cast("struct CPUInformation*", cpu_info_raw) or error("[Error] 0x03")

-- gpu stuff
local mat_system_interface = client.create_interface("materialsystem.dll", "VMaterialSystem080") or error("[Error] 0x04")
local mat_system_raw = ffi.cast("void***", mat_system_interface) or error("[Error] 0x04")
local material_system = mat_system_raw[0]
local get_active_adapter = ffi.cast("get_current_adapter_fn", material_system[25]) or error("[Error] 0x05")
local get_adapter_info = ffi.cast("get_adapter_info_fn", material_system[26]) or error("[Error] 0x06")

local active_adapter = get_active_adapter(material_system)

local adapter_info = ffi.new("struct MaterialAdapterInfo_t")

get_adapter_info(material_system, active_adapter, adapter_info)


--//
if common_hwid, pos_in_table == false then return end

--[[ui.set_visible(blossom_sexy_tranny_design2, false)
ui.set_visible(blossom_sexy_tranny_design3, false)
ui.set_visible(blossom_sexy_tranny_design5, false)
ui.set_visible(blossom_sexy_tranny_design6, false)
ui.set_visible(blossom_sexy_tranny_left, false)
ui.set_visible(blossom_sexy_tranny_right, false)
ui.set_visible(blossom_sides_conditions, false)
ui.set_visible(blossom_sides_conditions, false)
ui.set_visible(blossom_sexy_tranny_design5, false)
ui.set_visible(blossom_sexy_tranny_design5, false)]]--

ui_set = ui.set
ui_get = ui.get
ui_new_checkbox = ui.new_checkbox
ui_new_slider = ui.new_slider
ui_new_multiselect = ui.new_multiselect
ui_new_hotkey = ui.new_hotkey
ui_set_visible = ui.set_visible
ui_reference = ui.reference

client_draw_text = client.draw_text
client_screen_size = client.screen_size
client_camera_angles = client.camera_angles
client_set_event_callback = client.set_event_callback
client_trace_bullet = client.trace_bullet
client_eye_position = client.eye_position
client_visible = client.visible
client_userid_to_entindex = client.userid_to_entindex
client_get_cvar = client.get_cvar
client_set_cvar = client.set_cvar
client_log = client.log
client_screensize = client.screen_size
client_random_int = client.random_int
client_key_state = client.key_state

local entity_get_prop = entity.get_prop
local entity_is_enemy = entity.is_enemy
local entity_is_alive = entity.is_alive
local entity_is_dormant = entity.is_dormant
local entity_get_players = entity.get_players
local entity_hitbox_position = entity.hitbox_position
local entity_get_local_player = entity.get_local_player
local entity_get_player_name = entity.get_player_name
local entity_get_player_weapon = entity.get_player_weapon
local entity_get_bounding_box = entity.get_bounding_box
local entity_get_player_resource = entity.get_player_resource

local globals_tickinterval = globals.tickinterval
local globals_tickcount = globals.tickcount
local globals_curtime = globals.curtime
local globals_realtime = globals.realtime
local interval_per_tick = globals.tickinterval

local bit_band = bit.band
local math_pi   = math.pi
local math_min  = math.min
local math_max  = math.max
local math_deg  = math.deg
local math_rad  = math.rad
local math_sqrt = math.sqrt
local math_sin  = math.sin
local math_cos  = math.cos
local math_atan = math.atan
local math_atan2 = math.atan2
local math_acos = math.acos
local math_fmod = math.fmod
local math_ceil = math.ceil
local math_pow = math.pow
local math_abs = math.abs
local math_floor = math.floor

--//REFs
local aa_state = ui_reference("AA", "Anti-aimbot angles", "Enabled")
aa_pitch = ui.reference("AA", "Anti-aimbot angles", "Pitch")
local aa_yaw, aa_yaw_offset = ui_reference("AA", "Anti-aimbot angles", "Yaw")
local aa_yaw_jitter, aa_yaw_jitter_offset = ui_reference("AA", "Anti-aimbot angles", "Yaw jitter")
local aa_yaw_base = ui_reference("AA", "Anti-aimbot angles", "Yaw base")
local aa_fake_yaw, aa_fake_yaw_slider = ui_reference("AA", "Anti-aimbot angles", "body yaw")
local aa_fs_byaw = ui_reference("AA", "Anti-aimbot angles", "Freestanding body yaw")
local aa_fs_triggers, aa_bind_fs = ui_reference("AA", "Anti-aimbot angles", "Freestanding")
local aa_body_limit = ui_reference("AA", "Anti-aimbot angles", "fake yaw limit")
local aa_edge = ui_reference("AA", "Anti-aimbot angles", "Edge yaw")
local misc_legs = ui_reference("AA", "other", "leg movement")
local aa_fake_walk,fake_walk = ui_reference("AA", "other", "slow motion")
local misc_doubletap,doubletap = ui_reference("rage", "other", "double tap")
local misc_onshot, misc_onshot_aa = ui_reference("AA", "Other", "On shot anti-aim")
local misc_fakeduck = ui_reference("RAGE", "Other", "Duck peek assist")
local dt, dt_key = ui.reference("RAGE", "Other", "Double tap")

client.set_event_callback("paint", function()
    for i = 1, 400 do
        ui.set_visible(aa_state, false)
        ui.set_visible(aa_pitch, false)
        ui.set_visible(aa_yaw, false)
        ui.set_visible(aa_yaw_offset, false)
        ui.set_visible(aa_yaw_jitter, false)
        ui.set_visible(aa_yaw_jitter_offset, false)
        ui.set_visible(aa_yaw_base, false)
        ui.set_visible(aa_fake_yaw, false)
        ui.set_visible(aa_fake_yaw_slider, false)
        ui.set_visible(aa_fs_byaw, false)
        ui.set_visible(aa_body_limit, false)
        ui.set_visible(aa_fake_walk, true)
        ui.set_visible(fake_walk, true)
        ui.set_visible(misc_doubletap, true)
        ui.set_visible(doubletap, true)
        ui.set_visible(misc_onshot, true)
        ui.set_visible(misc_onshot_aa, true)
        ui.set_visible(aa_edge, false)
        ui.set_visible(aa_fs_triggers, false)
        ui.set_visible(aa_bind_fs, true)
        ui.set_visible(misc_fakeduck, true)
    end
end)
local retarded_label = ui.new_label("AA", "anti-aimbot angles", "default freestanding on key")
--//for i=1, 9999 do client.color_log(255, 0, 0, "I FUCKED YOUR FAMILY LLOLOLOOOLOL.") end
--// here we start making design :o
blossom_start = ui.new_label("AA", "anti-aimbot angles", "  = w = | B L O S S O M | = w =")
 
blossom_sexy_tranny_design1 = ui.new_checkbox("AA", "anti-aimbot angles", "            Enable Blossom")
blossom_sexy_tranny_design2 = ui.new_combobox("AA", "anti-aimbot angles", "                  options", "default", "automatic", "manual")
blossom_sexy_tranny_left = ui.new_hotkey("AA", "anti-aimbot angles", "       manual left direction")
blossom_sexy_tranny_right = ui.new_hotkey("AA", "anti-aimbot angles", "      manual right direction")
blossom_sexy_tranny_design3 = ui.new_multiselect("AA", "anti-aimbot angles", "             local anti-aim", "at targets", "head rotation", "edge yaw")
blossom_sides_conditions = ui.new_combobox("AA", "anti-aimbot angles", "head rotation options", "CT", "T")
--//blossom_sexy_tranny_design4, blossom_fs_key = ui.new_hotkey("AA", "anti-aimbot angles", "         freestanding on key")
blossom_sexy_tranny_design5 = ui.new_hotkey("AA", "anti-aimbot angles", "           at targets on key")
blossom_sexy_tranny_design6 = ui.new_combobox("AA", "anti-aimbot angles", "              freestanding", "Off", "normal", "freestanding+")

blossom_last = ui.new_label("AA", "anti-aimbot angles", "  = w = | B L O S S O M | = w =")

local cube_indic = ui.new_checkbox("AA", "Fake lag", "Indicator Blossom test")
-- Rounding Function
function round(num, numDecimalPlaces)
    local mult = 10^(numDecimalPlaces or 0)
    return math.floor(num * mult + 0.5) / mult
end

local function contains(table, val)
    for i = 1, #table do
        if table[i] == val then
            return true
        end
    end
    return false
end

--// china detectors
local china_freestand = 0
local enemy_from_china = nil
local fuck_china_information = {}
local china_food_angle = {}
local china_fire_back = {}

local function vec3_dot(ax, ay, az, bx, by, bz)
	return ax*bx + ay*by + az*bz
end

local function vec3_normalize(x, y, z)
	local len = math_sqrt(x * x + y * y + z * z)
	if len == 0 then
		return 0, 0, 0
	end
	local r = 1 / len
	return x*r, y*r, z*r
end

local function angle_to_vec(pitch, yaw)
	local p, y = math_rad(pitch), math_rad(yaw)
	local sp, cp, sy, cy = math_sin(p), math_cos(p), math_sin(y), math_cos(y)
	return cp*cy, cp*sy, -sp
end

local function get_fov_cos(ent, vx,vy,vz, lx,ly,lz)
	local ox,oy,oz = entity_get_prop(ent, "m_vecOrigin")
	if ox == nil then
		return -1
	end

	-- get direction to player
	local dx,dy,dz = vec3_normalize(ox-lx, oy-ly, oz-lz)
	return vec3_dot(dx,dy,dz, vx,vy,vz)
end

local function Angle_Vector(angle_x, angle_y)
	local sp, sy, cp, cy = nil
    sy = math_sin(math_rad(angle_y));
    cy = math_cos(math_rad(angle_y));
    sp = math_sin(math_rad(angle_x));
    cp = math_cos(math_rad(angle_x));
    return cp * cy, cp * sy, -sp;
end

local function CalcAngle(localplayerxpos, localplayerypos, enemyxpos, enemyypos)
   local relativeyaw = math_atan( (localplayerypos - enemyypos) / (localplayerxpos - enemyxpos) )
    return relativeyaw * 180 / math.pi
end

local function normalise_angle(angle)
	angle =  angle % 360 
	angle = (angle + 360) % 360
	if (angle > 180)  then
		angle = angle - 360
	end
	return angle
end

local function extrapolate_position(xpos,ypos,zpos,ticks,player)
	local x,y,z = entity_get_prop(player, "m_vecVelocity")
	for i=0, ticks do
		xpos =  xpos + (x*globals_tickinterval())
		ypos =  ypos + (y*globals_tickinterval())
		zpos =  zpos + (z*globals_tickinterval())
	end
	return xpos,ypos,zpos
end

local function get_velocity(player)
	local x,y,z = entity_get_prop(player, "m_vecVelocity")
	if x == nil then return end
	return math_sqrt(x*x + y*y + z*z)
end

local function get_max_body_yaw(player)
	local x,y,z = entity_get_prop(player, "m_vecVelocity")
	return 58 - 58 * math_sqrt(x ^ 2 + y ^ 2) / 580
end

local function get_body_yaw(player)
	local _, model_yaw = entity_get_prop(player, "m_angAbsRotation")
	local _, eye_yaw = entity_get_prop(player, "m_angEyeAngles")
	if model_yaw == nil or eye_yaw ==nil then return 0 end
	return normalise_angle(model_yaw - eye_yaw)
end

local function on_ground(player)
	local flags = entity_get_prop(player, "m_fFlags")
	
	if bit_band(flags, 1) == 1 then
		return true
	end
	
	return false
end

local function in_air(player)
	local flags = entity_get_prop(player, "m_fFlags")
	
	if bit_band(flags, 1) == 0 then
		return true
	end
	
	return false
end

local function is_crouching(player)
	local flags = entity_get_prop(player, "m_fFlags")
	
	if bit_band(flags, 4) == 4 then
		return true
	end
	
	return false
end

--// invalid-user's CHINA ANTI-BRUTEFORCE (c) invalid-user <---
local function china_closet_points(A, B, P)
    local a_to_p = { P[1] - A[1], P[2] - A[2] }
    local a_to_b = { B[1] - A[1], B[2] - A[2] }
    local ab = a_to_b[1]^2 + a_to_b[2]^2
    local dots = a_to_p[1]*a_to_b[1] + a_to_p[2]*a_to_b[2]
    local t = dots / ab
     
    return { A[1] + a_to_b[1]*t, A[2] + a_to_b[2]*t }
end

client.set_event_callback("bullet_impact", function(c)
    local ent = client.userid_to_entindex(c.userid)
        if not entity.is_dormant(ent) and entity.is_enemy(ent) and ent == enemy_from_china then
            local ent_shoot = { entity.get_prop(ent, "m_vecOrigin") }
            ent_shoot[3] = ent_shoot[3] + entity.get_prop(ent, "m_vecViewOffset[2]")
            local player_head = { entity.hitbox_position(entity.get_local_player(), 0) }
            local closest = china_closet_points(ent_shoot, { c.x, c.y, c.z }, player_head)
            local delta = { player_head[1]-closest[1], player_head[2]-closest[2] }
            local delta_2d = math.sqrt(delta[1]^2+delta[2]^2)
			
            if math.abs(delta_2d) < 25 and ui.get(aa_body_limit) > 35 or 31 then
                fuck_china_information[ent] = true
				china_food_angle[ent] = ui_get(aa_fake_yaw_slider)
				china_fire_back[ent] = globals.curtime() + 2.1
            end
		else
			fuck_china_information[ent] = false
        end
end)



local function menu_tranny_design()
    local state = ui.get(blossom_sexy_tranny_design1)
    ui.set_visible(blossom_sexy_tranny_design2, state)
    ui.set_visible(blossom_sexy_tranny_design3, state)
    --//ui.set_visible(blossom_sexy_tranny_design4, state)
    ui.set_visible(blossom_sexy_tranny_design5, state)
    ui.set_visible(blossom_sexy_tranny_design6, state)
    --//ui.set_visible(blossom_sexy_tranny_design7, state)
    local manual_state = ui.get(blossom_sexy_tranny_design2) == "manual" and ui.get(blossom_sexy_tranny_design1)
        ui.set_visible(blossom_sexy_tranny_left, manual_state)
        ui.set_visible(blossom_sexy_tranny_right, manual_state)

    local fixshit = contains(ui.get(blossom_sexy_tranny_design3),"head rotation") and ui.get(blossom_sexy_tranny_design1)
    if fixshit then
        ui.set_visible(blossom_sides_conditions, fixshit)
    else
        ui.set_visible(blossom_sides_conditions, false)
    end

    local state_fix = contains(ui.get(blossom_sexy_tranny_design3),"at targets") and ui.get(blossom_sexy_tranny_design1)
    if state_fix then
        ui.set_visible(blossom_sexy_tranny_design5, false)
    else
        ui.set_visible(blossom_sexy_tranny_design5, state)
    end
end
client.set_event_callback("paint", menu_tranny_design)
--// CHINA DETECTOR
local function enemy_is_peeking_and_can_hit_us(ent)
	if ent == nil then return end
	local origin_x, origin_y, origin_z = entity_get_prop(ent, "m_vecOrigin")
	local vx,vy,vz = entity_get_prop(enemy_from_china, "m_vecViewOffset")
	if origin_z == nil then return end
	origin_x,origin_y,origin_z = origin_x+vx,origin_y+vy,origin_z+vz

	--origin_z = origin_z + 64
	local lp = entity_get_local_player()
	
	if (get_velocity(ent) < 20) or in_air(ent) or in_air(entity_get_local_player()) then return false end

	local extrapolated_x, extrapolated_y, extrapolated_z = extrapolate_position(origin_x, origin_y, origin_z, 16, ent)
	--origin_x, origin_y, origin_z
	--
	local hx,hy,hz = entity_hitbox_position(lp, 0)
	local lx,ly,lz = client_eye_position()
	lz = hz
	
	local _, eye_yaw = entity_get_prop(lp, "m_angEyeAngles")
	local desync = normalise_angle(eye_yaw + (get_body_yaw(lp)))
	local real_x = lx + math_cos(math_rad(desync)) * 20
	local real_y = ly + math_sin(math_rad(desync)) * 12
	
	local desynced = normalise_angle(eye_yaw - (get_body_yaw(lp)))
	local fake_x = lx + math_cos(math_rad(desynced)) * 20
	local fake_y = ly + math_sin(math_rad(desynced)) * 12
	local head_idx, head_dmg = client_trace_bullet(ent, extrapolated_x, extrapolated_y, extrapolated_z, real_x, real_y, lz,true)
	local fake_idx, fake_dmg = client_trace_bullet(ent, extrapolated_x, extrapolated_y, extrapolated_z, fake_x, fake_y, lz,true)

	local predicted_damage = 0
	local desynced_damage = 0
	local timer = 0

	if head_dmg ~= nil and head_dmg > 0 then
		predicted_damage = head_dmg
	else
		predicted_damage = 0
	end
	
	if fake_dmg ~= nil and fake_dmg > 0 then
		desynced_damage = fake_dmg
	else
		desynced_damage = 0
	end
	
	if flip_angle then return false end
	--if predicted_damage == desynced_damage then return false end
	if predicted_damage <= desynced_damage then return false end

	--client.log("real: ", predicted_damage, " fake: ", desynced_damage, " comb: ",comb)
	return predicted_damage ~= nil and predicted_damage > 58
	
end

--//freestanding options
local function freestand_default()
    ui.set(aa_fs_triggers, "Default")
end
local function freestand_none()
    ui.set(aa_fs_triggers, " ")
end
--//at targets
local function edge_yaw_class()
    if contains(ui.get(blossom_sexy_tranny_design3),"edge yaw") and ui.get(blossom_sexy_tranny_design1) then
        ui.set(aa_edge, true)
    else
        ui.set(aa_edge, false)
    end
end
--//head rotation
local function head_rotation_class()
    if ui.get(blossom_sexy_tranny_design2) == "manual" and ui.get(blossom_sexy_tranny_design1) then return end
    local local_player = entity.get_local_player()
    if contains(ui.get(blossom_sexy_tranny_design3),"head rotation") and ui.get(blossom_sexy_tranny_design1) then
        head_rotate = client.random_int(1, 2)
        local random_yaw = client.random_int(6,13)
        local random_yaw1 = client.random_int(-13,-5)
        if is_crouching(local_player) then
            ui.set(aa_yaw_offset, random_yaw)
        end
            if on_ground(local_player) and not is_crouching(local_player) then
                ui.set(aa_yaw_offset, random_yaw1)
            end
                if in_air(local_player) and not on_ground(local_player) and not is_crouching(local_player) then
                    if head_rotate == 1 then
                    ui.set(aa_yaw_offset, -9)
                    elseif head_rotate == 2 then
                        ui.set(aa_yaw_offset, 9)
                    end 
                end
    end
end
--//edge yaw
local function at_targets_class()
    if contains(ui.get(blossom_sexy_tranny_design3),"at targets") and ui.get(blossom_sexy_tranny_design1) then
        ui.set(aa_yaw_base, "At targets")
    else
        ui.set(aa_yaw_base, "Local view")
    end
        
end
--//freestand_onkey
local function freestand_key_class()
    if ui.get(aa_bind_fs) then
        ui.set(aa_fs_triggers, "Default")
    else
        ui.set(aa_fs_triggers, " ")
    end
end

--//anti-aim default

local function main_antiaims_class()
    local head_slc = contains(ui.get(blossom_sexy_tranny_design3),"head rotation") and ui.get(blossom_sexy_tranny_design1)
    aa_fake_body = client.random_int(1, 3)
    if ui.get(blossom_sexy_tranny_design2) == "default" and ui.get(blossom_sexy_tranny_design1) then
        ui_set(aa_pitch, "Minimal")
        ui_set(aa_yaw_jitter, "off")
        ui_set(aa_fake_yaw, "static")
        ui_set(aa_fake_yaw_slider, 75)
        ui_set(aa_body_limit,client.random_int(21,32))
        if not head_slc then 
            ui.set(aa_yaw_offset, 3) 
        else 
            head_rotation_class() 
        end
    end
    if ui.get(blossom_sexy_tranny_design2) == "automatic" and ui.get(blossom_sexy_tranny_design1) then
        ui_set(aa_pitch, "Minimal")
        ui_set(aa_yaw_jitter, "off")
        if aa_fake_body == 1 then
            ui.set(aa_fake_yaw, "static")
            ui_set(aa_fake_yaw_slider, 75)
        elseif aa_fake_body == 2 then
            ui.set(aa_fake_yaw, "jitter")
            ui_set(aa_fake_yaw_slider, 0)
        end
        ui_set(aa_body_limit,client.random_int(59,51))
        if not head_slc then 
            ui.set(aa_yaw_offset, 8) 
        else 
            head_rotation_class() 
        end
    end
    if ui.get(blossom_sexy_tranny_design2) == "manual" and ui.get(blossom_sexy_tranny_design1) then
        --//main manual anti-aim settings...
        ui_set(aa_pitch, "Minimal")
        ui_set(aa_yaw_jitter, "off")
        ui_set(aa_fake_yaw, "static")
        ui_set(aa_fake_yaw_slider, 95)
        ui_set(aa_body_limit,client.random_int(27,36))
        --//manual anti-aim seciton below...
        ui_set(blossom_sexy_tranny_left, "Toggle")
		ui_set(blossom_sexy_tranny_right, "Toggle")
        if ui_get(blossom_sexy_tranny_design2) == "manual" and ui.get(blossom_sexy_tranny_left) then
            ui_set(aa_pitch, "Minimal")
            ui.set(aa_yaw_offset, -90)
		else
            ui.set(aa_yaw_offset, 0)
        	if ui_get(blossom_sexy_tranny_design2) == "manual" and ui.get(blossom_sexy_tranny_right) then
        	    ui_set(aa_pitch, "Minimal")
            	ui.set(aa_yaw_offset, 90)
			else
                ui.set(aa_yaw_offset, 0)
			end
        end
    end
end

local function log_weird(player)
        if ui.get(blossom_sexy_tranny_design2) == "automatic" and ui.get(blossom_sexy_tranny_design1) then
            local unknown = "error"
            local known = "anim"
            local random_shit = { [0] = 51, [1] = 23, [2] = 17, [3] = 43, [4] = 32, }
            new_text = random_shit[math.random(0, 4)]
            client.log("E: [" .. entity.get_player_name(player) .. "] I: [" .. known .. "] F: [" .. client.random_float(-60,60) .. "] Y: [" .. client.random_int(-24,32) .. "] ")
            unknown = new_text
        end
end

client.set_event_callback("aim_miss", function(info)
    log_weird(info.target)
end)

local function freestand_test()
    --// insane coded by poison <---
    if ui.get(aa_bind_fs) then 
        freestand_default()
    else
        freestand_none()
    end
end

--// freestanding+

local function against_china_angles(mode,offset)
    local crouching_ct = is_crouching(entity_get_local_player()) and entity_get_prop(entity_get_local_player(),"m_iTeamNum") == 3
	local crouching_t = is_crouching(entity_get_local_player()) and entity_get_prop(entity_get_local_player(),"m_iTeamNum") == 2
    if mode == 1 then
        if crouching_ct then
            ui.set(aa_fake_yaw_slider, 177)
            ui.set(aa_body_limit,32)

        else
            ui.set(aa_fake_yaw_slider, -177)
            ui.set(aa_body_limit,34)
        end
    end
    if mode == 2 then
        if crouching_t then
            ui.set(aa_fake_yaw_slider, -177)
            ui.set(aa_body_limit,36)

        else
            ui.set(aa_fake_yaw_slider, 177)
            ui.set(aa_body_limit,31)
        end
    end
end

local function freestanding_plus()
    if ui.get(blossom_sexy_tranny_design6) == "freestanding+" and ui.get(blossom_sexy_tranny_design1) then 
        if ArmyLeft then
            against_china_angles(1, 177)
        elseif ArmyRight then
            against_china_angles(2, -177)
        end
        if enemy_is_peeking_and_can_hit_us(enemy_from_china) and (china_freestand < globals_curtime()) then
            china_freestand = globals_curtime() + 5
            if (china_freestand < globals_curtime()) then
                ui.set(aa_fake_yaw_slider, 177)
            else
                ui.set(aa_fake_yaw_slider, -177)
            end
        else
            if (china_freestand > globals_curtime()) then
                ui.set(aa_fake_yaw_slider, -177)
            else
                ui.set(aa_fake_yaw_slider, 177)
            end
        end
    end
end

--//local anti-aim
client.set_event_callback("run_command", function()
    main_antiaims_class()
    edge_yaw_class()
    at_targets_class()
    head_rotation_class()
    freestand_key_class()
    freestand_test()
    freestanding_plus()
end)

local function indicator()
    local scrsize_x, scrsize_y = client_screensize()
    local center_x, center_y = scrsize_x / 2, scrsize_y / 2

    if not ui_get(cube_indic) then return end
    local local_player = entity.get_local_player()
    if not entity.is_alive(local_player) then return end
                for i = 1, 400 do
                    renderer.indicator(0, 0, 0, 0, " ")
                end
    local body_yaw = math.max(-60, math.min(60, round((entity.get_prop(local_player, "m_flPoseParameter", 11) or 0)*120-60+0.5, 1)))
    renderer.text(center_x+17, center_y+20, 153, 153, 153, 255, "-c", 0, "["..body_yaw.."Â°".."]")
    renderer.text(center_x-15, center_y+20, 205, 26, 67, 255, "-c", 0, "BLOSSOM") -- up text
        renderer.gradient(center_x, center_y+30, 35, 1, 153, 153, 153, 255, --[[ 2nd color ]] 255, 255, 255, 255, true) -- right
        renderer.gradient(center_x, center_y+30, -35.01, 1, 153, 153, 153, 255, --[[ 2nd color ]] 255, 255, 255, 255, true) -- left

        if ui.get(blossom_sexy_tranny_design2) == "automatic" and ui.get(blossom_sexy_tranny_design1) then
            renderer.text(center_x, center_y+40, 153, 153, 153, 255, "-c", 0, "AUTO") -- automatic option text

            if not ui_get(dt) or not ui_get(dt_key) then
                renderer.text(center_x, center_y+50, 153, 153, 153, 255, "-c", 0, "DT") -- dt text
            else 
                renderer.text(center_x, center_y+50, 205, 26, 67, 255, "-c", 0, "DT") -- dt text
            end
        end

        if ui.get(blossom_sexy_tranny_design2) == "default" and ui.get(blossom_sexy_tranny_design1) then
            renderer.text(center_x, center_y+40, 153, 153, 153, 255, "-c", 0, "DEFAULT") -- default option text

            if not ui_get(dt) or not ui_get(dt_key) then
                renderer.text(center_x, center_y+50, 153, 153, 153, 255, "-c", 0, "DT") -- dt text
            else 
                renderer.text(center_x, center_y+50, 205, 26, 67, 255, "-c", 0, "DT") -- dt text
            end
        end

        if ui.get(blossom_sexy_tranny_design2) == "manual" and ui.get(blossom_sexy_tranny_design1) then
            renderer.text(center_x, center_y+40, 153, 153, 153, 255, "-c", 0, "MANUAL") -- default option text

            if not ui_get(dt) or not ui_get(dt_key) then
                renderer.text(center_x, center_y+50, 153, 153, 153, 255, "-c", 0, "DT") -- dt text
            else 
                renderer.text(center_x, center_y+50, 205, 26, 67, 255, "-c", 0, "DT") -- dt text
            end

            if ui.get(blossom_sexy_tranny_left) and ui.get(blossom_sexy_tranny_design2) == "manual" and ui.get(blossom_sexy_tranny_design1) then
                renderer.text(center_x-47, center_y, 205, 26, 67, 200, "+cb", 0, "<") -- left text
                renderer.text(center_x+46, center_y, 153, 153, 153, 200, "+cb", 0, ">") -- right text
            else
                if ui.get(blossom_sexy_tranny_right) and ui.get(blossom_sexy_tranny_design2) == "manual" and ui.get(blossom_sexy_tranny_design1) then
                    renderer.text(center_x-47, center_y, 153, 153, 153, 200, "+cb", 0, "<") -- left text
                    renderer.text(center_x+46, center_y, 205, 26, 67, 200, "+cb", 0, ">") -- right text
                end
            end
        end
        --//test
        client.draw_text(center_x, center_y+60, 205, 26, 67, 255, nil, 0, string.format("%s", ui.get(aa_fake_yaw_slider)))

end
client.set_event_callback("paint", indicator)
